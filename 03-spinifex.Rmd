---
chapter: 3
knit: "bookdown::render_book"
---

# *spinifex*: extending *tourr* with manual tours and graphic display {#ch:spinifex}

## Abstract

Touring teqniques offer a great opertunity for data-space vizualization of ($p > 3$) multivariate data sets. This paper discusses the *R* package *spinifex*, which adds support for the manual tour, which is particularly usefuly for exploring the local structure after identifying a feature of interest, perhaps via guided tour. Additionally, *spinifex* extends graphic outputs to *plotly* and *gganimation*. This work extends the functionality of and is compatible with *tourr*.

Keywords: grand tour, projection pursuit, manual tour, tourr, touring, high dimenson visualization, hihg dim vis, dimensionality reduction, visualization, statistical graphics, data-space.


## Introduction

Both classical and contemorary visualizations of data are presented in two dimensions, that of a computer monitor or in print. How is it that we come to view and share data that exsists in $p > 3$ dimensions? In an appeal to brievity we shall ignore model and parameter summarization due to there shortcomings [@anscombe_graphs_1973; @matejka_same_2017]. Within the realm of data-space visualization we are left with projecting higher volumes and embedding them within lower dimensional spaces that we can vizualize.

This is not a new phenomena, such linear projections have been in use for quite some time. [@PCA; @LDA-FISCHer1936] and the myriad of single value deconcomposistion (SVD) techniques from numerous disciplines use such embeddings. Previous application look at data in one (or few) static orientations, after some objective optimization. For instance in PCA, we reorient $p$-dimensions such that we have a reference to the ordered components that describe a descending ammount of variation held within the data. Yet we still have $p$ components remaining to visualize. Where does the dimension reduction come in? From plotting only the first two or three and potenially another dimension tied to data point asthetic. This is maximizes the ammount of variation that can be display in an emedding, but regually discards a large proportion of the variation held within the data.

More recently non-linear dimensionality techniques have become popular, such as t-distributed stchocastic neighbor embedding (t-SNE) [@maaten_visualizing_2008], building off of sammon mappings [@sammon_nonlinear_1969]. Such non-linear methods make for astounding distinction when in low $d$ embeddings, but contain inhearant shortcomings. Namely: that the non-linear tranformations break inter-operability back to the original data-space, and that they can suffer from overfitting. If there is no inherent clustering with the data, it's posible that noise within the variables may become the proment feature and be displayed erroneously as group clustering.

[@asimov_grand_1985; @buja_grand_1986] suggested grand tours in which random walks in $p$-space can be interpolated and embedded in $d$ dimensions which are then viewed in sequence. The broader scope of touring has some beneficial features, namely: touring keeps the original dimensionality in tact unlike tradition static linear-projections, and maintains inter-operabilty in the orginal dimensions, a primary drawback of non-linear dimensionality reduction.

TODO: clean up above, talk about what 

## Terminology and demystifying projection:

Suppose that we have tri-variate data, $\textbf{X}_{[8,~3]}$, the corners points of a rectanguloid. We can describe the relative orientation by defining 



For every $p$-dimensional space can be described by the direction and magnitude of  axes in a square matrix that we call a basis. Imgine 3 axes of an XYZ Caresian volume (*ie.* a basis $\in \mathbb{R}^p$). In matimatical form we would write this as a diagonal identity matrix of demension 3.

```{r}
b <- diag(3)
xyz <- c("X", "Y", "Z")
rownames(b) <- xyz
colnames(b) <- xyz
b
```
This basis has some nice properties that are mathimatically nice to preserve, namely, that each axis as is at a right angle to the other (*orthagonal*), and are unit *normal* (length or norm equal to one). If matrix meets both of these criteria we call it *orthonormal*.



```{r}
set.seed(15)
library(plotly)
library(processx)
X = 9*runif(100) # X = 9*c(0,1,1,0,0,1,1,0)
Y = 6*runif(100) # Y = 6*c(0,0,1,1,0,0,1,1)
Z = 2*runif(100) # Z = 2*c(0,0,0,0,1,1,1,1)

p <- plot_ly(x=X, y=Y, z=Z, type="scatter3d", mode="markers")
###STATIC OUTPUT REQURIES ORCA SETUP, NOT TRANsFERABLE...
# orca(p, "cube_demo.png") # but, needs orca setup, 
# plotly_IMAGE(p, format = "png", out_file = "output.png")
```



## Manual tour

Let's explore the process behind the manual tour

Given:

\begin{description}
  \item[$\textbf{X}_{[n,~p]}$] A dataset contaning $n$ observations of $p$ numeric variables. 
  \item[$\textbf{B}_{[p,~d]}$] An orthonormal \footnote{Where each variable is both: orthagonal, at right angles (dot product is 0) to the other variabels, and unit vectors, a norm = 1} basis describing the current orientation projecting $p$ down to $d$ dimension.
\end{description}

\begin{align*}
  \textbf{X}_{[n,~p]} ~=
  \begin{bmatrix}
    X_{1,~1} & \dots  & X_{1,~p} \\
    X_{2,~1} & \dots  & X_{2,~p} \\
    \vdots   & \ddots & \vdots   \\
    X_{n,~1} & \dots  & X_{n,~p}
  \end{bmatrix}
\end{align*}

\begin{align*}
  \textbf{B}_{[p,~d]} ~=
  \begin{bmatrix}
    B_{1,~1} & \dots  & B_{1,~d} \\
    B_{2,~1} & \dots  & B_{2,~d} \\
    \vdots   & \ddots & \vdots   \\
    B_{p,~1} & \dots  & B_{p,~d}
  \end{bmatrix}
\end{align*}

Let *d = 2* for the sake of illustration.

Select a manip var, *k*, and use the Gram-Schmidt process to orthornormalize the concatenation of the zero vector with the *k*-th element set to 1, yielding the manipulation space, $\textbf{M}_{[p,~d+1]}$.

\begin{align*}
  \textbf{M}_{[p,~d+1]}
    &= Orthnormalize_{GS}( \textbf{B}_{[p,~d]}|\textbf{e}_{k~[p,~1]} ) \\
    &= Orthnormalize_{GS}
    \left(
      \begin{bmatrix}
        B_{1,~1} & B_{1,~2}\\
        B_{2,~1} & B_{2,~2}\\
        \vdots   & \vdots  \\
        B_{k,~1} & B_{k,~2}\\
        \vdots   & \vdots  \\
        B_{p,~1} & B_{p,~2}
      \end{bmatrix}
    ~|~
      \begin{bmatrix}
      0 \\
      0 \\
      \vdots \\
      1 \\
      \vdots \\
      0
      \end{bmatrix}
    \right)
\end{align*}

* Select $\theta$, angle of rotation with-in the plane of the XY projection, and a vector of $\phi_i$, the angle of out-of plane rotation, orthagonal to the projection plane (relative to $\phi_1$, the transformation $\phi_i$ - $\phi_1$ proved to be helpful to discuss $\phi$ relative to the Z axis.) 

**For ** $i$ **in 1 to n_slides:**
<!-- Don't fix the above, it's not going to happen... -->

* For each $\phi_i$, post multiplying 

$\textbf{M}_{[p, d+1]}$ by a rotation matrix, $\textbf{R}_{d+1, d+1}$ producing as many basis-projections, $\textbf{P}_{b[p, d+1]}$.

\begin{align}
  \textbf{P}_{b[p,~d+1]}
    &= \textbf{M}_{[p,~d+1]} ~*~ \textbf{R}_{[d+1,~d+1]}
    &= \begin{bmatrix}
        M_{1,~1} & M_{1,~2} & M_{1,~3} \\
        M_{2,~1} & M_{2,~2} & M_{2,~3} \\
        \vdots   & \vdots   & \vdots   \\
        M_{p,~1} & M_{p,~2} & M_{p,~3}
    \end{bmatrix}
      ~*~
    \begin{bmatrix}
      c_\theta^2 c_\phi s_\theta^2 &
      -c_\theta s_\theta (1 - c_\phi) &
      -c_\theta s_\phi \\
      -c_\theta s_\theta (1 - c_\phi) &
      s_\theta^2 c_\phi + c_\theta^2 &
      -s_\theta s_\phi \\
      c_\theta s_\phi &
      s_\theta s_\phi &
      c_\phi
    \end{bmatrix}
\end{align}

where:

\begin{description}
  \item[$\theta$] is the angle that lies on the projection plane ($ie.$ on the XY plane)
  \item[$\phi$] is the angle orthagonal to the projection plane ($ie.$ in the Z direction)
  \item[$c_\theta$] is the cosine of $\theta$
  \item[$c_\phi$]   is the cosine of $\phi$
  \item[$s_\theta$] is the sine of   $\theta$
  \item[$s_\phi$]   is the sine of   $\phi$
\end{description}

* To get back to data-space post multply each projection basis by the data, $\textbf{X}_{[n x p]}$, for $\textbf{P}_{d[n x d+1]}$.

\begin{align}
  \textbf{P}_{d[n,~d+1]}
    &= \textbf{X}_{[n,~p]} ~*~ \textbf{P}_{b[p,~d+1]}
    &= \begin{bmatrix}
      X_{1,~1} & \dots & X_{1,~p} \\
      X_{2,~1} & \dots & X_{2,~p} \\
      \vdots   & \vdots & \vdots  \\
      X_{n,~1} & \dots & X_{n,~p}
    \end{bmatrix}
      ~*~
    \begin{bmatrix}
      P_{b:1,~1} & P_{b:1,~2} & P_{b:1,~3} \\
      P_{b:2,~1} & P_{b:2,~2} & P_{b:2,~3} \\
      \vdots     & \vdots     & \vdots     \\
      P_{b:p,~1} & P_{b:p,~2} & P_{b:p,~3}
    \end{bmatrix}
\end{align}


* View the first two variables from each projection in sequence for an XY scatterplot. The remaining variable is sometimes utilized to produce depth cues used in conjunction with the XY scatterplot.

```{r}
library(spinifex)
flea_std <- tourr::rescale(tourr::flea[,1:6])
rb <- tourr::basis_random(n = ncol(flea_std))

spinifex(data = flea_std, basis = rb, manip_var = 4)
```
  TODO: PDF output is a static image w/ play slider.